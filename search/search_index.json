{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"python-mini-lambda (mini_lambda) \u00b6 Simple Lambda functions without lambda x: and with string conversion capability repr is now enabled by default for expressions and functions! More details here mini_lambda allows developers to write simple expressions with a subset of standard python syntax, without the lambda x: prefix. These expressions can easily be transformed into functions. It is possible to get a string representation of both. Among many potential use cases, the original motivation came from valid8 where we want to let users provide their own validation functions, while still being able to raise user-friendly exceptions \"showing\" the formula that failed. Installing \u00b6 > pip install mini_lambda Usage \u00b6 a- Principles \u00b6 Three basic steps: import or create a 'magic variable' (an InputVar ) such as x , s , l , df ... write an expression using it. transform the expression into a function by wrapping it with _() , L() , or F() (3 aliases), or by calling as_function() on it. For example with a numeric variable: # -- expressions -- from mini_lambda import x my_expr = x ** 2 my_expr # <LambdaExpression: x ** 2> my_expr ( 12 ) # beware: calling an expression is still an expression ! # <LambdaExpression: (x ** 2)(12)> # -- functions -- from mini_lambda import _ my_func = _ ( x ** 2 ) my_func # <LambdaFunction: x ** 2> assert my_func ( 12 ) == 144 # calling a function executes it as expected Or with a string variable: # create or import a magic variable, here we import 's' from mini_lambda import s # write an expression and wrap it with _() to make a function from mini_lambda import _ say_hello_function = _ ( 'Hello, ' + s + ' !' ) # use the function with any input say_hello_function ( 'world' ) # Returns \"Hello, world !\" # the function's string representation is available print ( say_hello_function ) # \"'Hello, ' + s + ' !'\" b- Capabilities \u00b6 The variable can represent anything, not necessarily a primitive. If you wish to use another symbol just define it using InputVar : from mini_lambda import InputVar z = InputVar ( 'z' ) from logging import Logger l = InputVar ( 'l' , Logger ) Note that the type information is optional, it is just for your IDE's autocompletion capabilities. Most of python syntax can be used in an expression: from mini_lambda import x , s , _ from mini_lambda.symbols.math_ import Log # various lambda functions is_lowercase = _ ( s . islower () ) get_prefix_upper_shebang = _ ( s [ 0 : 4 ] . upper () + ' !' ) numeric_test_1 = _ ( - x > x ** 2 ) numeric_test_2 = _ ( (( 1 - 2 * x ) <= - x ) | ( - x > x ** 2 ) ) complex_identity = _ ( Log ( 10 ** x , 10 ) ) # use the functions is_lowercase ( 'Hello' ) # returns False get_prefix_upper_shebang ( 'hello' ) # returns 'HELL !' numeric_test_1 ( 0.5 ) # returns False numeric_test_2 ( 1 ) # returns True complex_identity ( 10 ) # returns 10 # string representation print ( is_lowercase ) # s.islower() print ( get_prefix_upper_shebang ) # s[0:4].upper() + ' !' print ( numeric_test_1 ) # -x > x ** 2 print ( numeric_test_2 ) # (1 - 2 * x <= -x) | (-x > x ** 2) print ( complex_identity ) # log(10 ** x, 10) If you know python you should feel at home here, except for two things: or and and should be replaced with their bitwise equivalents | and & additional constants, methods and classes need to be made lambda-friendly before use. For convenience all of the built-in functions as well as constants, methods and classes from the math.py and decimal.py modules are provided in a lambda-friendly way by this package, hence the from mini_lambda.symbols.math_ import Log above. Note that the printed version provides the minimal equivalent representation taking into account operator precedence. Hence numeric_test_2 got rid of the useless parenthesis. This is not a mathematical simplification like in SymPy , i.e. x - x will not be simplified to 0 . There are of course a few limitations to mini_lambda as compared to full-flavoured python lambda functions, the main ones being that you can't mix more than one variable in the same expression for now. The resulting functions therefore have a single argument only. list / tuple / set / dict comprehensions are not supported ... if ... else ... ternary conditional expressions are not supported either Check the Usage page for more details. New: repr now enabled by default \u00b6 Starting in version 2.0.0, the representation of lambda expressions does not raise exceptions anymore by default. This behaviour was a pain for developers, and was only like this for the very rare occasions where repr was needed in the expression itself. So now >>> from mini_lambda import x , F >>> x ** 2 < LambdaExpression : x ** 2 > >>> F ( x ** 2 ) < LambdaFunction : x ** 2 > If you wish to bring back the old exception-raising behaviour, simply set the repr_on attribute of your expressions to False : >>> from mini_lambda import x >>> x . repr_on = False >>> x ** 2 ( ... ) mini_lambda . base . FunctionDefinitionError : __repr__ is not supported by this Lambda Expression . ( ... ) c- How to support mini-lambda expressions in your libraries. \u00b6 You may wish to support mini-lambda expressions (not functions ) directly into your code. That way, your users will not even have to convert their expressions into functions - this will bring more readability and ease of use for them. You can do this with as_function : this will convert expressions to functions if needed, but otherwise silently return its input. from mini_lambda import _ , s , as_function def call_with_hello ( f ): \"\"\"An example custom method that is lambda_friendy\"\"\" # transform mini-lambda expression to function if needed. f = as_function ( f ) return f ( 'hello' ) # it works with a normal function def foo ( s ): return s [ 0 ] assert call_with_hello ( foo ) == 'h' # with a mini-lambda *Function* (normal: this is a function) assert call_with_hello ( _ ( s [ 0 ])) == 'h' # and with a mini-lambda *Expression* too (this is new and easier to read) assert call_with_hello ( s [ 0 ]) == 'h' In addition a is_mini_lambda_expr helper is also provided, if you wish to perform some reasoning: from mini_lambda import x , is_mini_lambda_expr , as_function # mini lambda: true assert is_mini_lambda_expr ( x ** 2 ) # standard lambda: false assert not is_mini_lambda_expr ( lambda x : x ) # standard function: false def foo (): pass assert not is_mini_lambda_expr ( foo ) # mini lambda as function: false f = as_function ( x ** 2 ) assert not is_mini_lambda_expr ( f ) Main features \u00b6 More compact lambda expressions for single-variable functions As close to python syntax as technically possible: the base type for lambda expressions in mini_lambda , LambdaExpression , overrides all operators that can be overriden as of today in python . The remaining limits come from the language itself, for example chained comparisons and and/or are not supported as python casts the partial results to boolean to enable short-circuits. Details here . Printability: expressions can be turned to string representation in order to (hopefully) get interpretable messages more easily, for example when the expression is used in a validation context See Also \u00b6 The much-broader debate in the python community about alternate lambda syntaxes is interesting, see here Equivalent (python-first) \u00b6 I found the following libraries somehow covering the same use case, with more or less success/features: SymPy is the most well known symbolic computation framework in python. It provides a printable Lambda() object, but it does not seem to support all operators (see this post ). lambdaX lambdazen . Based on python source code generation at runtime using a decorator. The main drawback is the need to define lambdas inside a decorated function. fixing lambda and its associated toy library quicklambda . It is not very exhaustive. pyexpression is quite similar to quicklambda (above) fz is also inspired by quicklambda (above). Note: it is GPL-licensed. A bit far from the topic but related: * letexpr for let expression like Haskell * calchylus : lisp-like expressions in python based on Hy * MiniOperators String expression-first \u00b6 These libraries create functions from string expressions. Therefore you cannot rely on your favourite IDE to check your expressions, but it might not be a problem for some users/use cases. simpleeval ... (feel free to suggest more) ... Others \u00b6 Do you like this library ? You might also like my other python libraries Want to contribute ? \u00b6 Details on the github page: https://github.com/smarie/python-mini-lambda","title":"Home"},{"location":"#python-mini-lambda-mini_lambda","text":"Simple Lambda functions without lambda x: and with string conversion capability repr is now enabled by default for expressions and functions! More details here mini_lambda allows developers to write simple expressions with a subset of standard python syntax, without the lambda x: prefix. These expressions can easily be transformed into functions. It is possible to get a string representation of both. Among many potential use cases, the original motivation came from valid8 where we want to let users provide their own validation functions, while still being able to raise user-friendly exceptions \"showing\" the formula that failed.","title":"python-mini-lambda (mini_lambda)"},{"location":"#installing","text":"> pip install mini_lambda","title":"Installing"},{"location":"#usage","text":"","title":"Usage"},{"location":"#a-principles","text":"Three basic steps: import or create a 'magic variable' (an InputVar ) such as x , s , l , df ... write an expression using it. transform the expression into a function by wrapping it with _() , L() , or F() (3 aliases), or by calling as_function() on it. For example with a numeric variable: # -- expressions -- from mini_lambda import x my_expr = x ** 2 my_expr # <LambdaExpression: x ** 2> my_expr ( 12 ) # beware: calling an expression is still an expression ! # <LambdaExpression: (x ** 2)(12)> # -- functions -- from mini_lambda import _ my_func = _ ( x ** 2 ) my_func # <LambdaFunction: x ** 2> assert my_func ( 12 ) == 144 # calling a function executes it as expected Or with a string variable: # create or import a magic variable, here we import 's' from mini_lambda import s # write an expression and wrap it with _() to make a function from mini_lambda import _ say_hello_function = _ ( 'Hello, ' + s + ' !' ) # use the function with any input say_hello_function ( 'world' ) # Returns \"Hello, world !\" # the function's string representation is available print ( say_hello_function ) # \"'Hello, ' + s + ' !'\"","title":"a- Principles"},{"location":"#b-capabilities","text":"The variable can represent anything, not necessarily a primitive. If you wish to use another symbol just define it using InputVar : from mini_lambda import InputVar z = InputVar ( 'z' ) from logging import Logger l = InputVar ( 'l' , Logger ) Note that the type information is optional, it is just for your IDE's autocompletion capabilities. Most of python syntax can be used in an expression: from mini_lambda import x , s , _ from mini_lambda.symbols.math_ import Log # various lambda functions is_lowercase = _ ( s . islower () ) get_prefix_upper_shebang = _ ( s [ 0 : 4 ] . upper () + ' !' ) numeric_test_1 = _ ( - x > x ** 2 ) numeric_test_2 = _ ( (( 1 - 2 * x ) <= - x ) | ( - x > x ** 2 ) ) complex_identity = _ ( Log ( 10 ** x , 10 ) ) # use the functions is_lowercase ( 'Hello' ) # returns False get_prefix_upper_shebang ( 'hello' ) # returns 'HELL !' numeric_test_1 ( 0.5 ) # returns False numeric_test_2 ( 1 ) # returns True complex_identity ( 10 ) # returns 10 # string representation print ( is_lowercase ) # s.islower() print ( get_prefix_upper_shebang ) # s[0:4].upper() + ' !' print ( numeric_test_1 ) # -x > x ** 2 print ( numeric_test_2 ) # (1 - 2 * x <= -x) | (-x > x ** 2) print ( complex_identity ) # log(10 ** x, 10) If you know python you should feel at home here, except for two things: or and and should be replaced with their bitwise equivalents | and & additional constants, methods and classes need to be made lambda-friendly before use. For convenience all of the built-in functions as well as constants, methods and classes from the math.py and decimal.py modules are provided in a lambda-friendly way by this package, hence the from mini_lambda.symbols.math_ import Log above. Note that the printed version provides the minimal equivalent representation taking into account operator precedence. Hence numeric_test_2 got rid of the useless parenthesis. This is not a mathematical simplification like in SymPy , i.e. x - x will not be simplified to 0 . There are of course a few limitations to mini_lambda as compared to full-flavoured python lambda functions, the main ones being that you can't mix more than one variable in the same expression for now. The resulting functions therefore have a single argument only. list / tuple / set / dict comprehensions are not supported ... if ... else ... ternary conditional expressions are not supported either Check the Usage page for more details.","title":"b- Capabilities"},{"location":"#new-repr-now-enabled-by-default","text":"Starting in version 2.0.0, the representation of lambda expressions does not raise exceptions anymore by default. This behaviour was a pain for developers, and was only like this for the very rare occasions where repr was needed in the expression itself. So now >>> from mini_lambda import x , F >>> x ** 2 < LambdaExpression : x ** 2 > >>> F ( x ** 2 ) < LambdaFunction : x ** 2 > If you wish to bring back the old exception-raising behaviour, simply set the repr_on attribute of your expressions to False : >>> from mini_lambda import x >>> x . repr_on = False >>> x ** 2 ( ... ) mini_lambda . base . FunctionDefinitionError : __repr__ is not supported by this Lambda Expression . ( ... )","title":"New: repr now enabled by default"},{"location":"#c-how-to-support-mini-lambda-expressions-in-your-libraries","text":"You may wish to support mini-lambda expressions (not functions ) directly into your code. That way, your users will not even have to convert their expressions into functions - this will bring more readability and ease of use for them. You can do this with as_function : this will convert expressions to functions if needed, but otherwise silently return its input. from mini_lambda import _ , s , as_function def call_with_hello ( f ): \"\"\"An example custom method that is lambda_friendy\"\"\" # transform mini-lambda expression to function if needed. f = as_function ( f ) return f ( 'hello' ) # it works with a normal function def foo ( s ): return s [ 0 ] assert call_with_hello ( foo ) == 'h' # with a mini-lambda *Function* (normal: this is a function) assert call_with_hello ( _ ( s [ 0 ])) == 'h' # and with a mini-lambda *Expression* too (this is new and easier to read) assert call_with_hello ( s [ 0 ]) == 'h' In addition a is_mini_lambda_expr helper is also provided, if you wish to perform some reasoning: from mini_lambda import x , is_mini_lambda_expr , as_function # mini lambda: true assert is_mini_lambda_expr ( x ** 2 ) # standard lambda: false assert not is_mini_lambda_expr ( lambda x : x ) # standard function: false def foo (): pass assert not is_mini_lambda_expr ( foo ) # mini lambda as function: false f = as_function ( x ** 2 ) assert not is_mini_lambda_expr ( f )","title":"c- How to support mini-lambda expressions in your libraries."},{"location":"#main-features","text":"More compact lambda expressions for single-variable functions As close to python syntax as technically possible: the base type for lambda expressions in mini_lambda , LambdaExpression , overrides all operators that can be overriden as of today in python . The remaining limits come from the language itself, for example chained comparisons and and/or are not supported as python casts the partial results to boolean to enable short-circuits. Details here . Printability: expressions can be turned to string representation in order to (hopefully) get interpretable messages more easily, for example when the expression is used in a validation context","title":"Main features"},{"location":"#see-also","text":"The much-broader debate in the python community about alternate lambda syntaxes is interesting, see here","title":"See Also"},{"location":"#equivalent-python-first","text":"I found the following libraries somehow covering the same use case, with more or less success/features: SymPy is the most well known symbolic computation framework in python. It provides a printable Lambda() object, but it does not seem to support all operators (see this post ). lambdaX lambdazen . Based on python source code generation at runtime using a decorator. The main drawback is the need to define lambdas inside a decorated function. fixing lambda and its associated toy library quicklambda . It is not very exhaustive. pyexpression is quite similar to quicklambda (above) fz is also inspired by quicklambda (above). Note: it is GPL-licensed. A bit far from the topic but related: * letexpr for let expression like Haskell * calchylus : lisp-like expressions in python based on Hy * MiniOperators","title":"Equivalent (python-first)"},{"location":"#string-expression-first","text":"These libraries create functions from string expressions. Therefore you cannot rely on your favourite IDE to check your expressions, but it might not be a problem for some users/use cases. simpleeval ... (feel free to suggest more) ...","title":"String expression-first"},{"location":"#others","text":"Do you like this library ? You might also like my other python libraries","title":"Others"},{"location":"#want-to-contribute","text":"Details on the github page: https://github.com/smarie/python-mini-lambda","title":"Want to contribute ?"},{"location":"changelog/","text":"Changelog \u00b6 2.2.2 - Minor packaging improvements \u00b6 Added __version__ attribute. Fixes #20 Improved setup.py , in particular long description now uses markdown (no pandoc anymore) and zip_safe is false. Fixes #18 Added py.typed file for PEP561 compliance. Fixes #19 2.2.1 - pyproject.toml \u00b6 Added pyproject.toml . 2.2.0 - Better signature for mini-lambda functions \u00b6 When converting an expression into a function, the resulting callable object now has the same signature than inner evaluate . Fixes #17 . 2.1.0 - New features to improve usability. \u00b6 Added two helper functions is_mini_lambda_expr and as_function . Fixes #13 Renamed _LambdaExpression to LambdaExpression . It is now exported at package lavel, that's clearer. Added __repr__ to LambdaFunction . Fixes #14 . 2.0.1 - fixed dependency issue \u00b6 in 2.0.0 pandas and numpy were mandatory again. Fixed that. 2.0.0 - python 2 support, default repr , and cleaner submodules structure \u00b6 Lambda expressions now have a normal repr by default, and this can be disabled by using the repr_on attribute to False . Fixes #12 Added support for python 2. Fixes #11 . The package structure is now cleaner. In particular, predefined variables are in mini_lambda.vars and predefined symbols (constants, functions and classes) are in mini_lambda.symbols . 1.4.0 - fixed initial import time + added And() and Or() \u00b6 Fixed #5 by making numpy and pandas import optional: they are now only imported if you import mini_lambda.numpy_ or mini_lambda.pandas_ respectively. New And() and Or() functions, see #7 1.3.1 - fixed ImportError in code generation \u00b6 the latest autoclass has its __init__.py fixed, this revealed a ImportError: cannot import name 'getmembers' because we were importing getmembers from it instead of inspect . Fixed 1.3.0 - fixed init .py \u00b6 The init file has been improved so as not to export symbols from other packages. Fixes #6 1.2.4 - Minor improvements in generated goodies \u00b6 Removed annoying warning message when loading goodies Removed useless try/except for goodies that do not need import 1.2.3 - Fixed minor bug in code generation \u00b6 Removed all None that were appearing in the goodies_generated.py file Now compliant with old versions of typing module: typing.Type is not imported explicitly anymore. 1.2.2 - Fixed code generation to solve two import errors \u00b6 Fixed #3 and #4 . Generated source code has been removed from version control to avoid this kind of errors in the future. Travis script has been equipped with an automatic module import checker to detect such issues earlier next time. 1.2.0 - New alias and bugfix for constant functions \u00b6 added alias make_lambda_friendly for Constant , since it is able to convert anything (constants, functions and classes) to lambda-friendly objects usable in expressions. Fixed #2 that was a bug happening when using lambda-friendly methods with non-lambda arguments 1.1.0 - Compatibility with standard functions \u00b6 It is now possible to use any function in a lambda expression, through use of the make_lambda_friendly_... methods (see documentation ) All built-in methods as well as all constants, methods and classes from the math.py and decimal.py modules are provided in a lambda-friendly way by the package for convenience Updated documentation accordingly, and made main page clearer Renamed class _InputEvaluator into _LambdaExpression A few bugfixes in particular support for keyword arguments when a function call is made in a lambda expression <expr>.nnot() , <expr>.any() and <expr>.all() renamed <expr>.not_() , <expr>.any_() and <expr>.all_() for consistency and to avoid conflicts with any()/all() methods that would already be defined in the class, for example NumPy. 1.0.0 - First public version \u00b6 Initial fork from valid8 sources. Added documentation and printability of expressions, which implied to properly handle operator precedence.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#222-minor-packaging-improvements","text":"Added __version__ attribute. Fixes #20 Improved setup.py , in particular long description now uses markdown (no pandoc anymore) and zip_safe is false. Fixes #18 Added py.typed file for PEP561 compliance. Fixes #19","title":"2.2.2 - Minor packaging improvements"},{"location":"changelog/#221-pyprojecttoml","text":"Added pyproject.toml .","title":"2.2.1 - pyproject.toml"},{"location":"changelog/#220-better-signature-for-mini-lambda-functions","text":"When converting an expression into a function, the resulting callable object now has the same signature than inner evaluate . Fixes #17 .","title":"2.2.0 - Better signature for mini-lambda functions"},{"location":"changelog/#210-new-features-to-improve-usability","text":"Added two helper functions is_mini_lambda_expr and as_function . Fixes #13 Renamed _LambdaExpression to LambdaExpression . It is now exported at package lavel, that's clearer. Added __repr__ to LambdaFunction . Fixes #14 .","title":"2.1.0 - New features to improve usability."},{"location":"changelog/#201-fixed-dependency-issue","text":"in 2.0.0 pandas and numpy were mandatory again. Fixed that.","title":"2.0.1 - fixed dependency issue"},{"location":"changelog/#200-python-2-support-default-repr-and-cleaner-submodules-structure","text":"Lambda expressions now have a normal repr by default, and this can be disabled by using the repr_on attribute to False . Fixes #12 Added support for python 2. Fixes #11 . The package structure is now cleaner. In particular, predefined variables are in mini_lambda.vars and predefined symbols (constants, functions and classes) are in mini_lambda.symbols .","title":"2.0.0 - python 2 support, default repr, and cleaner submodules structure"},{"location":"changelog/#140-fixed-initial-import-time-added-and-and-or","text":"Fixed #5 by making numpy and pandas import optional: they are now only imported if you import mini_lambda.numpy_ or mini_lambda.pandas_ respectively. New And() and Or() functions, see #7","title":"1.4.0 - fixed initial import time + added And() and Or()"},{"location":"changelog/#131-fixed-importerror-in-code-generation","text":"the latest autoclass has its __init__.py fixed, this revealed a ImportError: cannot import name 'getmembers' because we were importing getmembers from it instead of inspect . Fixed","title":"1.3.1 - fixed ImportError in code generation"},{"location":"changelog/#130-fixed-initpy","text":"The init file has been improved so as not to export symbols from other packages. Fixes #6","title":"1.3.0 - fixed init.py"},{"location":"changelog/#124-minor-improvements-in-generated-goodies","text":"Removed annoying warning message when loading goodies Removed useless try/except for goodies that do not need import","title":"1.2.4 - Minor improvements in generated goodies"},{"location":"changelog/#123-fixed-minor-bug-in-code-generation","text":"Removed all None that were appearing in the goodies_generated.py file Now compliant with old versions of typing module: typing.Type is not imported explicitly anymore.","title":"1.2.3 - Fixed minor bug in code generation"},{"location":"changelog/#122-fixed-code-generation-to-solve-two-import-errors","text":"Fixed #3 and #4 . Generated source code has been removed from version control to avoid this kind of errors in the future. Travis script has been equipped with an automatic module import checker to detect such issues earlier next time.","title":"1.2.2 - Fixed code generation to solve two import errors"},{"location":"changelog/#120-new-alias-and-bugfix-for-constant-functions","text":"added alias make_lambda_friendly for Constant , since it is able to convert anything (constants, functions and classes) to lambda-friendly objects usable in expressions. Fixed #2 that was a bug happening when using lambda-friendly methods with non-lambda arguments","title":"1.2.0 - New alias and bugfix for constant functions"},{"location":"changelog/#110-compatibility-with-standard-functions","text":"It is now possible to use any function in a lambda expression, through use of the make_lambda_friendly_... methods (see documentation ) All built-in methods as well as all constants, methods and classes from the math.py and decimal.py modules are provided in a lambda-friendly way by the package for convenience Updated documentation accordingly, and made main page clearer Renamed class _InputEvaluator into _LambdaExpression A few bugfixes in particular support for keyword arguments when a function call is made in a lambda expression <expr>.nnot() , <expr>.any() and <expr>.all() renamed <expr>.not_() , <expr>.any_() and <expr>.all_() for consistency and to avoid conflicts with any()/all() methods that would already be defined in the class, for example NumPy.","title":"1.1.0 - Compatibility with standard functions"},{"location":"changelog/#100-first-public-version","text":"Initial fork from valid8 sources. Added documentation and printability of expressions, which implied to properly handle operator precedence.","title":"1.0.0 - First public version"},{"location":"long_description/","text":"python-mini-lambda \u00b6 Simple lambda functions without lambda x: and with string conversion capability. Originally developed whithin the valid8 validation library. The documentation for users is available here: https://smarie.github.io/python-mini-lambda/ A readme for developers is available here: https://github.com/smarie/python-mini-lambda","title":"python-mini-lambda"},{"location":"long_description/#python-mini-lambda","text":"Simple lambda functions without lambda x: and with string conversion capability. Originally developed whithin the valid8 validation library. The documentation for users is available here: https://smarie.github.io/python-mini-lambda/ A readme for developers is available here: https://github.com/smarie/python-mini-lambda","title":"python-mini-lambda"},{"location":"usage/","text":"Usage details \u00b6 Input Variables \u00b6 An input variable is basically a symbolic string that you will use in your expressions. For example x , t , foo , ... It is created with the InputVar() method. It is recommended that your use the same string for the variable name and for its symbolic name, for example: from mini_lambda import InputVar t = InputVar ( 't' ) In addition, the InputVar method has a second optional typ argument. This argument is completely useless to mini_lambda , but it allows your IDE to provide you with useful autocompletion when writing expressions. from mini_lambda import InputVar import pandas as pd df = InputVar ( 'df' , pd . DataFrame ) df . #... enjoy IDE autocompletion when using df in your expressions! For convenience, mini_lambda comes bundled with the following predefined input variables: text/string: s boolean/int/float numbers: b / i , j , n / x , y lists/mappings: l / d callables: f numpy arrays (if numpy is present): X , Y , M (from mini_lambda.vars.numpy_ ) pandas dataframes (if pandas is present): df (from mini_lambda.vars.pandas_ ) Lambda Expressions vs Lambda Functions \u00b6 Creating an expression and Evaluating it \u00b6 Lambda expressions are obtained by using python syntax on variables. For example 2 * x + 1 is a valid expression. The simplest lambda expression is the variable itself. It is implemented with the identity function: when evaluated on some input, it directly returns that input. from mini_lambda import x # A variable is a lambda expression type ( x ) # <class 'mini_lambda.main.LambdaExpression'> # Evaluating the lambda expression applies the identity function x . evaluate ( 1234 ) # 1234 Obviously you want to construct expressions that are a bit more complex than the identity. Here is a slightly more complex example: from mini_lambda import x # An expression is built using python syntax with a variable my_first_expr = ( 1 + 1 ) * x + 1 > 0 my_first_expr . evaluate ( - 1 / 2 ) # False As seen above, an expression can be evaluated on an input by calling <expr>.evaluate(input) . The following steps happen: when my_first_expr is created, the python syntax simplifies itself automatically, as usual. So my_first_expr = (1 + 1) * x + 1 > 0 becomes my_first_expr = 2 * x + 1 > 0 before the expression is actually created. before entering evaluate , the arguments are also simplified automatically as usual. So my_first_expr.evaluate(-1/2) becomes my_first_expr.evaluate(-0.5) the first step in evaluate is that the value -0.5 is assigned to all parts of the expression containing the variable. Everywhere, x is replaced with -0.5 the second step in evaluate is to resolve the rest of the formula using plain old python. So 2 * -0.5 + 1 > 0 is executed, which yields False . String Representation \u00b6 A string representation of an expression can be obtained through the <expr>.to_string() method. This is one of the added values of mini_lambda with respect to standard lambda functions: x . to_string () # \"x\" my_first_expr . to_string () # \"2 * x + 1 > 0\" From expression (edit mode) to function (apply mode) \u00b6 An expression is in edit mode until you explicitly transform it to a function . That is why we had to use the evaluate and to_string functions explicitly in previous section, instead of the more pythonic <expr>(input) and str(<expr>) . Indeed, <expr>(input) would create a new expression instead of evaluating it: result = my_first_expr ( - 1 / 2 ) # still an expression ! type ( result ) # <class 'mini_lambda.main.LambdaExpression'> result . to_string () # \"(2 * x + 1 > 0)(-0.5)\" There are several ways to transform an expression to a plain old function: from mini_lambda import _ , L , F one = my_first_expr . as_function () # explicit conversion two = _ ( my_first_expr ) # _() does the same thing three = L ( my_first_expr ) # L() is an alias for _() four = F ( my_first_expr ) # F() is another alias for _() five , six = _ ( my_first_expr , x ) # both accept multiple arguments After converting an expression to a function, it is straightforward to use: # evaluation = calling the function one ( - 1 / 2 ), two ( - 1 / 2 ), three ( - 1 / 2 ), four ( - 1 / 2 ), five ( - 1 / 2 ) # all return False six ( - 1 / 2 ) # returns -0.5 # string representation = str() str ( one ) # \"2 * x + 1 > 0\" str ( six ) # \"x\" All at once \u00b6 Obviously you may wish to define a function directly in one line: from mini_lambda import s , _ , Print say_hello = _ ( Print ( 'Hello, ' + s + ' !' )) say_hello ( 'world' ) # \"Hello, world !\" Lambda Expression Syntax \u00b6 Let's now focus on how you can edit more complex expressions. Basically, most of python syntax is supported, either directly: from mini_lambda import i , s , l , f , d , x from math import trunc expr = i < 5 # comparing (<, >, <=, >=, ==, !=) expr = s . lower () # accessing fields and methods (recursive) expr = f ( 10 ) # calling expr = reversed ( l ) # reversing expr = d [ 'key' ] # getting expr = s [ 0 : 3 ] # slicing expr = 2 * i ** 5 % 2 # calc-ing (+,-,/,//,%,divmod,**,@,<<,>>,abs,~) expr = trunc ( x ) # calculating (round, math.trunc) expr = s . format ( 1 , 2 ) # formatting expr = ( x > 1 ) & ( x < 5 ) # boolean logic: &,|,^ or through provided workarounds : from mini_lambda import b , i , s , l , x from mini_lambda import Slice , Get , Not , In , And from mini_lambda import Iter , Repr , Str , Len , Int , Any from mini_lambda.symbols.math_ import Log from mini_lambda.symbols.decimal_ import DDecimal from math import log from decimal import Decimal # boolean logic expr = ( x > 1 ) and ( x < 5 ) # fails expr = ( x > 1 ) & ( x < 5 ) # OK expr = And ( x > 1 , x < 5 ) # OK # iterating expr = next ( iter ( s )) # fails expr = next ( Iter ( s )) # OK # calling with the variable as arg expr = log ( x ) # fails expr = Log ( x ) # OK # constructing with the variable as arg expr = Decimal ( x ) # fails expr = DDecimal ( x ) # OK # getting with the variable as the key expr = { 'a' : 1 }[ s ] # fails expr = Get ({ 'a' : 1 }, s ) # OK # slicing with the variable as index expr = 'hello' [ 0 : i ] # fails expr = Get ( 'hello' , Slice ( 0 , i )) # OK # representing: Repr/Str/Bytes/Sizeof/Hash # -- by default repr show the to_string() assert repr ( l ) == '<LambdaExpression: l>' # -- but you can disable it l . repr_on = False expr = repr ( l ) # fails # -- in both cases, if you need repr in the expression, use expr = Repr ( l ) # OK # formatting with the variable in the args expr = ' {} {} ' . format ( s , s ) # fails expr = Str . format ( ' {} {} ' , s , s ) # OK # sizing expr = len ( l ) # fails expr = Len ( l ) # OK # casting (Bool, Int, Float, Complex, Hex, Oct) expr = int ( s ) # fails expr = Int ( s ) # OK # not expr = not b # fails expr = b . not_ () # OK expr = Not ( b ) # OK # any/all expr = any ( l ) # fails expr = l . any_ () # OK expr = Any ( l ) # OK # membership testing (variable as container) expr = 'f' in l # fails expr = l . contains ( 'f' ) # OK expr = In ( 'f' , l ) # OK # membership testing (variable as item) expr = x in [ 1 , 2 ] # fails expr = x . is_in ([ 1 , 2 ]) # OK expr = In ( x , [ 1 , 2 ]) # OK As seen above, there are several types of defective behaviours: built-in behaviours such as len , int , ... for which the behaviour can be overridden according to the data model but for which the python framework unfortunately force checks the return type. For these methods even if we override the methods, since we return a lambda expression, the type checking fails. So we provide instead an implementation that always raises an exception, and provide a workaround function named with a similar name i.e. Int() to replace int() . built-in behaviours with special syntax ( not b , {'a': 1}[s] , x in y , any_(x) ). In which case an equivalent explicit method is provided: Not , Get , Slice , In , Any , All . In addition, equivalent methods <expr>.contains() , <expr>.is_in() , <expr>.not_() , <expr>.any_() , and <expr>.all_() are provided. the shortcircuit boolean operators and/or can not be overridden and check the return type, so you should use either bitwise combination ( & or | ) or logical ( And or Or ) instead. any other 'standard' methods, whether they are object constructors Decimal() or functions such as log() . We will see in the next section how you can convert any existing class or method to a lambda-friendly one. mini_lambda comes bundled with a few of them, namely all constants, functions and classes defined in math and decimal modules. Finally, the following python constructs can not be used at all expr = 0 < x < 1 # chained comparisons (use parenthesis and & instead) expr = [ i for i in l ] # list/tuple/set/dict comprehensions (no workaround) Supporting any other methods and classes \u00b6 Now you might wonder how to use all of this in practice, where you manipulate specific data types such as numpy arrays, pandas dataframes, etc. Here is how you convert items to lambda-friendly items Constants \u00b6 A constant is for example math.e or math.pi . Using constants in expressions can obviously be done without intervention, but they will not appear as named when printing the expression: from mini_lambda import x , _ from math import e # we can use any constant in an expression, but it will be evaluated when printed str ( _ ( x + e )) # 'x + 2.718281828459045' For this reason mini_lambda provides a Constant() method with aliases C() and make_lambda_friendly() to define a constant and assign it with a symbol. from mini_lambda import x , _ , C from math import e # define the constant E = C ( e , 'e' ) # use it in expressions. The name appears when printed str ( _ ( x + E )) # 'x + e' Functions \u00b6 Standard functions can be easily converted to be usable in expressions, through the make_lambda_friendly_method helper function: from mini_lambda import x , _ , make_lambda_friendly_method # (a) standard function def divide ( dummy , times , num , den = None ): \"\"\" This is an existing function that you want to convert \"\"\" return times * num / den # let's make the function lambda-friendly ! Divide = make_lambda_friendly_method ( divide ) # you can now use the function in an expression complex_constant = _ ( 1 + Divide ( None , x , den = x , num = 1 )) complex_constant ( 10 ) # 2 str ( complex_constant ) # '1 + divide(None, x, den=x, num=1)' Note that by default the name appearing in the expression is func.__name__ . It can be changed by setting the name parameter of make_lambda_friendly_method . Anonymous functions such as standard lambdas and functools partial functions can be converted too, but you'll have to explicitly provide a name: from mini_lambda import x , _ , make_lambda_friendly_method from math import log from functools import partial # (b) partial function (to fix leftmost positional args and/or keyword args) is_superclass_of_bool = make_lambda_friendly_method ( partial ( issubclass , bool ), name = 'is_superclass_of_bool' ) # now you can use it in your lambda expressions expr = _ ( is_superclass_of_bool ( x )) expr ( int ) # True expr ( str ) # False print ( expr ) # \"is_superclass_of_bool(x)\" # (c) lambda function Log10 = make_lambda_friendly_method ( lambda x : log ( x , 10 ), name = 'log10' ) # now you can use it in your lambda expressions complex_identity = _ ( Log10 ( 10 ** x )) complex_identity ( 3.5 ) # 3.5 print ( complex_identity ) # \"log10(10 ** x)\" Finally, it is possible to convert functions from classes in a similar way: from mini_lambda import x , _ , make_lambda_friendly_method # (d) standard function str.startswith (from class str) StartsWith = make_lambda_friendly_method ( str . startswith ) # now you can use it in your lambda expressions str_tester = _ ( StartsWith ( 'hello' , 'el' , x )) str_tester ( 0 ) # False str_tester ( 1 ) # True print ( str_tester ) # \"startswith('hello', 'el', x)\" # -- static and class functions class Foo : @staticmethod def bar1 ( times , num , den ): return times * num / den @classmethod def bar2 ( cls , times , num , den ): return times * num / den # (e) static functions FooBar1 = make_lambda_friendly_method ( Foo . bar1 ) fun1 = _ ( FooBar1 ( x , den = x , num = 1 ) ) # (f) class functions - with hardcoded cls argument FooBar2a = make_lambda_friendly_method ( Foo . bar2 ) fun2a = _ ( FooBar2a ( x , den = x , num = 1 ) ) # (g) class functions - with free cls argument FooBar2b = make_lambda_friendly_method ( Foo . bar2 . __func__ ) fun2b = _ ( FooBar2b ( Foo , x , den = x , num = 1 ) ) Note: although the above is valid, it is much more recommended to convert the whole class as we'll see in the next section. Classes \u00b6 Classes can be entirely made lambda-friendly at once. This will convert the constructor, as well as any other method that would be available. from mini_lambda import _ , make_lambda_friendly_class from mini_lambda.vars.numpy_ import X import numpy as np import pandas as pd DDataframe = make_lambda_friendly_class ( pd . DataFrame ) expr = _ ( DDataframe ( X ) . max () . values [ 0 ] ) expr ( np . array ([ 1 , 2 ])) # 2 str ( expr ) # 'DataFrame(X).max().values[0]' Anything \u00b6 Actually the Constant() (alias C() or make_lambda_friendly() ) function that we saw above to convert constants, is also able to convert methods ans classes. So if there is only a single conversion operator to remember, remember this one. from mini_lambda import _ , C from mini_lambda.vars.numpy_ import X import numpy as np import pandas as pd all_at_once = _ ( C ( print )( C ( pd . DataFrame )( X ) . transpose ()) ) all_at_once ( np . array ([ 1 , 2 ])) # prints # 0 1 # 0 1 2 str ( all_at_once ) # 'print(DataFrame(X).transpose())' Pre-converted constants, methods and classes \u00b6 For convenience all of the built-in functions as well as constants, methods and classes from the math.py and decimal.py modules are provided in a lambda-friendly way by this package. The naming rule is to capitalize lower-case names, and for already capitalized names to duplicate the first letter: # builtins are available at pkg root from mini_lambda import Print # all other symbols are in ther appropriate 'symbols' submodule from mini_lambda.symbols.builtins import Print # print() function from mini_lambda.symbols.math_ import Pi # math.pi constant from mini_lambda.symbols.decimal_ import DDecimal # Decimal class","title":"Usage details"},{"location":"usage/#usage-details","text":"","title":"Usage details"},{"location":"usage/#input-variables","text":"An input variable is basically a symbolic string that you will use in your expressions. For example x , t , foo , ... It is created with the InputVar() method. It is recommended that your use the same string for the variable name and for its symbolic name, for example: from mini_lambda import InputVar t = InputVar ( 't' ) In addition, the InputVar method has a second optional typ argument. This argument is completely useless to mini_lambda , but it allows your IDE to provide you with useful autocompletion when writing expressions. from mini_lambda import InputVar import pandas as pd df = InputVar ( 'df' , pd . DataFrame ) df . #... enjoy IDE autocompletion when using df in your expressions! For convenience, mini_lambda comes bundled with the following predefined input variables: text/string: s boolean/int/float numbers: b / i , j , n / x , y lists/mappings: l / d callables: f numpy arrays (if numpy is present): X , Y , M (from mini_lambda.vars.numpy_ ) pandas dataframes (if pandas is present): df (from mini_lambda.vars.pandas_ )","title":"Input Variables"},{"location":"usage/#lambda-expressions-vs-lambda-functions","text":"","title":"Lambda Expressions vs Lambda Functions"},{"location":"usage/#creating-an-expression-and-evaluating-it","text":"Lambda expressions are obtained by using python syntax on variables. For example 2 * x + 1 is a valid expression. The simplest lambda expression is the variable itself. It is implemented with the identity function: when evaluated on some input, it directly returns that input. from mini_lambda import x # A variable is a lambda expression type ( x ) # <class 'mini_lambda.main.LambdaExpression'> # Evaluating the lambda expression applies the identity function x . evaluate ( 1234 ) # 1234 Obviously you want to construct expressions that are a bit more complex than the identity. Here is a slightly more complex example: from mini_lambda import x # An expression is built using python syntax with a variable my_first_expr = ( 1 + 1 ) * x + 1 > 0 my_first_expr . evaluate ( - 1 / 2 ) # False As seen above, an expression can be evaluated on an input by calling <expr>.evaluate(input) . The following steps happen: when my_first_expr is created, the python syntax simplifies itself automatically, as usual. So my_first_expr = (1 + 1) * x + 1 > 0 becomes my_first_expr = 2 * x + 1 > 0 before the expression is actually created. before entering evaluate , the arguments are also simplified automatically as usual. So my_first_expr.evaluate(-1/2) becomes my_first_expr.evaluate(-0.5) the first step in evaluate is that the value -0.5 is assigned to all parts of the expression containing the variable. Everywhere, x is replaced with -0.5 the second step in evaluate is to resolve the rest of the formula using plain old python. So 2 * -0.5 + 1 > 0 is executed, which yields False .","title":"Creating an expression and Evaluating it"},{"location":"usage/#string-representation","text":"A string representation of an expression can be obtained through the <expr>.to_string() method. This is one of the added values of mini_lambda with respect to standard lambda functions: x . to_string () # \"x\" my_first_expr . to_string () # \"2 * x + 1 > 0\"","title":"String Representation"},{"location":"usage/#from-expression-edit-mode-to-function-apply-mode","text":"An expression is in edit mode until you explicitly transform it to a function . That is why we had to use the evaluate and to_string functions explicitly in previous section, instead of the more pythonic <expr>(input) and str(<expr>) . Indeed, <expr>(input) would create a new expression instead of evaluating it: result = my_first_expr ( - 1 / 2 ) # still an expression ! type ( result ) # <class 'mini_lambda.main.LambdaExpression'> result . to_string () # \"(2 * x + 1 > 0)(-0.5)\" There are several ways to transform an expression to a plain old function: from mini_lambda import _ , L , F one = my_first_expr . as_function () # explicit conversion two = _ ( my_first_expr ) # _() does the same thing three = L ( my_first_expr ) # L() is an alias for _() four = F ( my_first_expr ) # F() is another alias for _() five , six = _ ( my_first_expr , x ) # both accept multiple arguments After converting an expression to a function, it is straightforward to use: # evaluation = calling the function one ( - 1 / 2 ), two ( - 1 / 2 ), three ( - 1 / 2 ), four ( - 1 / 2 ), five ( - 1 / 2 ) # all return False six ( - 1 / 2 ) # returns -0.5 # string representation = str() str ( one ) # \"2 * x + 1 > 0\" str ( six ) # \"x\"","title":"From expression (edit mode) to function (apply mode)"},{"location":"usage/#all-at-once","text":"Obviously you may wish to define a function directly in one line: from mini_lambda import s , _ , Print say_hello = _ ( Print ( 'Hello, ' + s + ' !' )) say_hello ( 'world' ) # \"Hello, world !\"","title":"All at once"},{"location":"usage/#lambda-expression-syntax","text":"Let's now focus on how you can edit more complex expressions. Basically, most of python syntax is supported, either directly: from mini_lambda import i , s , l , f , d , x from math import trunc expr = i < 5 # comparing (<, >, <=, >=, ==, !=) expr = s . lower () # accessing fields and methods (recursive) expr = f ( 10 ) # calling expr = reversed ( l ) # reversing expr = d [ 'key' ] # getting expr = s [ 0 : 3 ] # slicing expr = 2 * i ** 5 % 2 # calc-ing (+,-,/,//,%,divmod,**,@,<<,>>,abs,~) expr = trunc ( x ) # calculating (round, math.trunc) expr = s . format ( 1 , 2 ) # formatting expr = ( x > 1 ) & ( x < 5 ) # boolean logic: &,|,^ or through provided workarounds : from mini_lambda import b , i , s , l , x from mini_lambda import Slice , Get , Not , In , And from mini_lambda import Iter , Repr , Str , Len , Int , Any from mini_lambda.symbols.math_ import Log from mini_lambda.symbols.decimal_ import DDecimal from math import log from decimal import Decimal # boolean logic expr = ( x > 1 ) and ( x < 5 ) # fails expr = ( x > 1 ) & ( x < 5 ) # OK expr = And ( x > 1 , x < 5 ) # OK # iterating expr = next ( iter ( s )) # fails expr = next ( Iter ( s )) # OK # calling with the variable as arg expr = log ( x ) # fails expr = Log ( x ) # OK # constructing with the variable as arg expr = Decimal ( x ) # fails expr = DDecimal ( x ) # OK # getting with the variable as the key expr = { 'a' : 1 }[ s ] # fails expr = Get ({ 'a' : 1 }, s ) # OK # slicing with the variable as index expr = 'hello' [ 0 : i ] # fails expr = Get ( 'hello' , Slice ( 0 , i )) # OK # representing: Repr/Str/Bytes/Sizeof/Hash # -- by default repr show the to_string() assert repr ( l ) == '<LambdaExpression: l>' # -- but you can disable it l . repr_on = False expr = repr ( l ) # fails # -- in both cases, if you need repr in the expression, use expr = Repr ( l ) # OK # formatting with the variable in the args expr = ' {} {} ' . format ( s , s ) # fails expr = Str . format ( ' {} {} ' , s , s ) # OK # sizing expr = len ( l ) # fails expr = Len ( l ) # OK # casting (Bool, Int, Float, Complex, Hex, Oct) expr = int ( s ) # fails expr = Int ( s ) # OK # not expr = not b # fails expr = b . not_ () # OK expr = Not ( b ) # OK # any/all expr = any ( l ) # fails expr = l . any_ () # OK expr = Any ( l ) # OK # membership testing (variable as container) expr = 'f' in l # fails expr = l . contains ( 'f' ) # OK expr = In ( 'f' , l ) # OK # membership testing (variable as item) expr = x in [ 1 , 2 ] # fails expr = x . is_in ([ 1 , 2 ]) # OK expr = In ( x , [ 1 , 2 ]) # OK As seen above, there are several types of defective behaviours: built-in behaviours such as len , int , ... for which the behaviour can be overridden according to the data model but for which the python framework unfortunately force checks the return type. For these methods even if we override the methods, since we return a lambda expression, the type checking fails. So we provide instead an implementation that always raises an exception, and provide a workaround function named with a similar name i.e. Int() to replace int() . built-in behaviours with special syntax ( not b , {'a': 1}[s] , x in y , any_(x) ). In which case an equivalent explicit method is provided: Not , Get , Slice , In , Any , All . In addition, equivalent methods <expr>.contains() , <expr>.is_in() , <expr>.not_() , <expr>.any_() , and <expr>.all_() are provided. the shortcircuit boolean operators and/or can not be overridden and check the return type, so you should use either bitwise combination ( & or | ) or logical ( And or Or ) instead. any other 'standard' methods, whether they are object constructors Decimal() or functions such as log() . We will see in the next section how you can convert any existing class or method to a lambda-friendly one. mini_lambda comes bundled with a few of them, namely all constants, functions and classes defined in math and decimal modules. Finally, the following python constructs can not be used at all expr = 0 < x < 1 # chained comparisons (use parenthesis and & instead) expr = [ i for i in l ] # list/tuple/set/dict comprehensions (no workaround)","title":"Lambda Expression Syntax"},{"location":"usage/#supporting-any-other-methods-and-classes","text":"Now you might wonder how to use all of this in practice, where you manipulate specific data types such as numpy arrays, pandas dataframes, etc. Here is how you convert items to lambda-friendly items","title":"Supporting any other methods and classes"},{"location":"usage/#constants","text":"A constant is for example math.e or math.pi . Using constants in expressions can obviously be done without intervention, but they will not appear as named when printing the expression: from mini_lambda import x , _ from math import e # we can use any constant in an expression, but it will be evaluated when printed str ( _ ( x + e )) # 'x + 2.718281828459045' For this reason mini_lambda provides a Constant() method with aliases C() and make_lambda_friendly() to define a constant and assign it with a symbol. from mini_lambda import x , _ , C from math import e # define the constant E = C ( e , 'e' ) # use it in expressions. The name appears when printed str ( _ ( x + E )) # 'x + e'","title":"Constants"},{"location":"usage/#functions","text":"Standard functions can be easily converted to be usable in expressions, through the make_lambda_friendly_method helper function: from mini_lambda import x , _ , make_lambda_friendly_method # (a) standard function def divide ( dummy , times , num , den = None ): \"\"\" This is an existing function that you want to convert \"\"\" return times * num / den # let's make the function lambda-friendly ! Divide = make_lambda_friendly_method ( divide ) # you can now use the function in an expression complex_constant = _ ( 1 + Divide ( None , x , den = x , num = 1 )) complex_constant ( 10 ) # 2 str ( complex_constant ) # '1 + divide(None, x, den=x, num=1)' Note that by default the name appearing in the expression is func.__name__ . It can be changed by setting the name parameter of make_lambda_friendly_method . Anonymous functions such as standard lambdas and functools partial functions can be converted too, but you'll have to explicitly provide a name: from mini_lambda import x , _ , make_lambda_friendly_method from math import log from functools import partial # (b) partial function (to fix leftmost positional args and/or keyword args) is_superclass_of_bool = make_lambda_friendly_method ( partial ( issubclass , bool ), name = 'is_superclass_of_bool' ) # now you can use it in your lambda expressions expr = _ ( is_superclass_of_bool ( x )) expr ( int ) # True expr ( str ) # False print ( expr ) # \"is_superclass_of_bool(x)\" # (c) lambda function Log10 = make_lambda_friendly_method ( lambda x : log ( x , 10 ), name = 'log10' ) # now you can use it in your lambda expressions complex_identity = _ ( Log10 ( 10 ** x )) complex_identity ( 3.5 ) # 3.5 print ( complex_identity ) # \"log10(10 ** x)\" Finally, it is possible to convert functions from classes in a similar way: from mini_lambda import x , _ , make_lambda_friendly_method # (d) standard function str.startswith (from class str) StartsWith = make_lambda_friendly_method ( str . startswith ) # now you can use it in your lambda expressions str_tester = _ ( StartsWith ( 'hello' , 'el' , x )) str_tester ( 0 ) # False str_tester ( 1 ) # True print ( str_tester ) # \"startswith('hello', 'el', x)\" # -- static and class functions class Foo : @staticmethod def bar1 ( times , num , den ): return times * num / den @classmethod def bar2 ( cls , times , num , den ): return times * num / den # (e) static functions FooBar1 = make_lambda_friendly_method ( Foo . bar1 ) fun1 = _ ( FooBar1 ( x , den = x , num = 1 ) ) # (f) class functions - with hardcoded cls argument FooBar2a = make_lambda_friendly_method ( Foo . bar2 ) fun2a = _ ( FooBar2a ( x , den = x , num = 1 ) ) # (g) class functions - with free cls argument FooBar2b = make_lambda_friendly_method ( Foo . bar2 . __func__ ) fun2b = _ ( FooBar2b ( Foo , x , den = x , num = 1 ) ) Note: although the above is valid, it is much more recommended to convert the whole class as we'll see in the next section.","title":"Functions"},{"location":"usage/#classes","text":"Classes can be entirely made lambda-friendly at once. This will convert the constructor, as well as any other method that would be available. from mini_lambda import _ , make_lambda_friendly_class from mini_lambda.vars.numpy_ import X import numpy as np import pandas as pd DDataframe = make_lambda_friendly_class ( pd . DataFrame ) expr = _ ( DDataframe ( X ) . max () . values [ 0 ] ) expr ( np . array ([ 1 , 2 ])) # 2 str ( expr ) # 'DataFrame(X).max().values[0]'","title":"Classes"},{"location":"usage/#anything","text":"Actually the Constant() (alias C() or make_lambda_friendly() ) function that we saw above to convert constants, is also able to convert methods ans classes. So if there is only a single conversion operator to remember, remember this one. from mini_lambda import _ , C from mini_lambda.vars.numpy_ import X import numpy as np import pandas as pd all_at_once = _ ( C ( print )( C ( pd . DataFrame )( X ) . transpose ()) ) all_at_once ( np . array ([ 1 , 2 ])) # prints # 0 1 # 0 1 2 str ( all_at_once ) # 'print(DataFrame(X).transpose())'","title":"Anything"},{"location":"usage/#pre-converted-constants-methods-and-classes","text":"For convenience all of the built-in functions as well as constants, methods and classes from the math.py and decimal.py modules are provided in a lambda-friendly way by this package. The naming rule is to capitalize lower-case names, and for already capitalized names to duplicate the first letter: # builtins are available at pkg root from mini_lambda import Print # all other symbols are in ther appropriate 'symbols' submodule from mini_lambda.symbols.builtins import Print # print() function from mini_lambda.symbols.math_ import Pi # math.pi constant from mini_lambda.symbols.decimal_ import DDecimal # Decimal class","title":"Pre-converted constants, methods and classes"}]}